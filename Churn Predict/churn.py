# -*- coding: utf-8 -*-
"""Churn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iReIek1aZOi5Kx6znz-1r_E3rt4lrf6t
"""

#Importando as bibliotecas
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import categorical_crossentropy

#Importando arquivo
from google.colab import files
arquivo = files.upload()

df = pd.read_csv('Telco-Customer-Churn.csv')

df_val = df.iloc[:10]
df_val

#Retirar o campo customerID
df.drop('customerID', 1, inplace=True)

#Verifica tipos
df.dtypes

#Altera TotalCharges
df.TotalCharges = pd.to_numeric(df.TotalCharges, errors="coerce")

#Verifica Vazios
df.TotalCharges.isna()

#Ver campos vazios
df[df.TotalCharges.isna()]

#Exclusao dos campos vazios de TotalCharges
df.dropna(subset=['TotalCharges'], inplace=True)

df

#Grafico para analise de tenure
dfno = df[df.Churn=='No'].tenure
dfyes = df[df.Churn=='Yes'].tenure

plt.hist([dfno, dfyes], color=['blue', 'red'], label=['Churn = No', 'Churn = Yes'])
plt.legend()

#Grafico dependentes

dfno = df[df.Churn=='No'].Dependents
dfyes = df[df.Churn=='Yes'].Dependents

plt.hist([dfno, dfyes], color=['blue', 'red'], label=['Churn = No', 'Churn = Yes'])
plt.legend()

#Grafico de MonthlyCharges
dfno = df[df.Churn=='No'].MonthlyCharges
dfyes = df[df.Churn=='Yes'].MonthlyCharges

plt.hist([dfno, dfyes], color=['blue', 'red'], label=['Churn = No', 'Churn = Yes'])
plt.legend()

#Balanceamento do dataset
dfno = df[df.Churn=='No'].Churn
dfyes = df[df.Churn=='Yes'].Churn

total = dfno.count() + dfyes.count()
percent = round((dfyes.count() / total) * 100 , 2)

print(f'NO: {dfno.count()}', f'YES: {dfyes.count()}', f' Yesr % No: {percent}')

plt.hist([dfno, dfyes], color=['blue', 'red'], label=['Churn = No', 'Churn = Yes'])
plt.legend()

#Verifica padrao
for i in df:
  if df[i].dtypes == 'object':
    print(f'{i} : {df[i].unique()}')

df.replace('No internet service', 'No', inplace=True)
df.replace('No phone service', 'No', inplace=True)

df

dfnum = pd.get_dummies(data=df, columns=['gender','InternetService', 'Partner','Dependents','PhoneService','MultipleLines','InternetService','OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies','Contract','PaperlessBilling','PaymentMethod'])
dfnum.columns

dfnum.sample(5)

#Label Encoder / Transforma Yes ou No de Churn em 1 ou 0
le = LabelEncoder()
dfnum['Churn'] = le.fit_transform(dfnum['Churn'])
dfnum.Churn.sample(15)

scaler = MinMaxScaler()
dfnum[['tenure','MonthlyCharges','TotalCharges']] = scaler.fit_transform(dfnum[['tenure','MonthlyCharges','TotalCharges']])
dfnum.sample(5)

#Separar features e labels
features = dfnum.drop(['Churn'], 1)
label = dfnum['Churn']

#Parte para validação
val = features.head(10)
val

#Novo feature
features = features.iloc[10:]
label = label.iloc[10:]

#Separa entre treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(features, label, test_size=.20, random_state=42)

model = Sequential([
Dense(20, input_shape=(41,), activation='relu'),
Dense(52, activation='relu'),
Dense(1, activation='sigmoid')
])

#Passando parametro de execução
model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

#Treinamento

model.fit(X_train, y_train, epochs=100)

pred_val = model.predict(val)
print(pred_val)

y_pred = []
for i in pred_val:
  if i > 0.5:
    y_pred.append(1)
  else:
    y_pred.append(0)

cliente = df_val['customerID']
real = df_val['Churn']
pred = list(pred_val.flatten())

df = pd.DataFrame({'cliente':cliente, 'previsao': pred, 'real':real, 'churn':y_pred})

print(df)

import seaborn as sns

df = pd.DataFrame(df, columns=['real', 'churn'])
confusion_matrix = pd.crosstab(df['real'], df['churn'], rownames=['real'], colnames=['churn'])

sns.heatmap(confusion_matrix, annot=True)

